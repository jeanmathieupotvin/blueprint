% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Atomic.R
\name{Atomic}
\alias{Atomic}
\alias{is_atomic}
\alias{valid_atomic}
\title{Atomic: a class for strict atomic vectors}
\usage{
## Test if an object is an 'Atomic' object
is_atomic(x)

## Validate if an object is a proper 'Atomic' object
valid_atomic(x)
}
\arguments{
\item{x}{any \R object.}
}
\value{
\itemize{
\item External helper function \code{\link[=is_atomic]{is_atomic()}} returns a logical scalar.
}

\itemize{
\item External helper function \code{\link[=valid_atomic]{valid_atomic()}} returns a logical scalar if
the object is valid. Else, an error explaining what is wrong is returned.
}
}
\description{
\link{Atomic} is an important building block of \pkg{blueprint}: it creates
blueprints for \link[=is_strict_atomic]{strict atomic vectors} (vectors of
any \R atomic type, including \link{NULL}, that has no attribute). Instances
of the \link{Atomic} class hold useful (derived) metadata on strict vectors:
their types, names, prototypes and optionally, their lengths.
}
\section{Self-validation}{

The contents of an instance is checked when it is initialized and each time
a method is called afterward.
}

\section{Updating fields of the Atomic class}{

Users should \strong{never} manually change fields' values of an \link{Atomic} instance
manually. Instead, use \code{\link[=Atomic]{$set()}} to do it safely. Refer to the
documentation of this method (see below) for more information.
}

\examples{

## ------------------------------------------------
## Method `Atomic$new`
## ------------------------------------------------

## Create a blueprint and do not enforce a length.
Atomic$new(1L, "myVectorName")

## Create a blueprint that enforces a specific length; here, 10.
Atomic$new(1L, "myVectorName", 10L)

## ------------------------------------------------
## Method `Atomic$compare`
## ------------------------------------------------

## Compare values against an Atomic blueprint that do not enforce a length.
bp_no_length <- Atomic$new("hello", "myBlueprint")

bp_no_length$compare(c("hi", "bye")) # TRUE
bp_no_length$compare("bye")          # TRUE
bp_no_length$compare(1)              # FALSE

## Compare values against an Atomic blueprint that enforces a length.
bp_length <- Atomic$new("hello", "myBlueprint", 1L)

bp_length$compare(c("hi", "bye")) # FALSE
bp_length$compare("bye")          # TRUE
bp_length$compare(1)              # FALSE

## ------------------------------------------------
## Method `Atomic$bind`
## ------------------------------------------------

## Create an environment.
env <- new.env()

## Spawn a vector from a blueprint and bind the result to $name
## in env. We also lock the binding.
b <- Atomic$new(12.0, "vector", 1000L)$bind(env, TRUE)

## Trying to change value of a locked binding results in an error.
\dontrun{env$vector <- 1.0}

## You can later unlock the binding.
unlockBinding("vector", env)
env$vector <- "new value"

## Bind a prototype to $name within a list.
lst <- list(value = 1L)
b$bind(lst)
lst$vector

## ------------------------------------------------
## Method `Atomic$as_yaml`
## ------------------------------------------------

## Create an Atomic object.
ab <- Atomic$new(sample.int(10L), "randomValues", 10L)

## Create a simple YAML representation and print it.
cat(ab$as_yaml())

## Add additional headers to output.
myheaders <- list(author = "JM Potvin", date = "January 1st 2021")
cat(ab$as_yaml(headers = myheaders))

## Write output to a file.
ab$as_yaml(file = "my_atomic.yaml", headers = myheaders)

## Output is always encoded to UTF-8.
Encoding(ab$as_yaml(headers = list(utf8char = "`"))) == "UTF-8"

## You can pass additional parameters to yaml::as.yaml().
cat(ab$as_yaml(indent = 4L))

## Use custom handlers.
## Here, we use another handler for raw values.
handlers <- list(
    raw = function(x) { return(as.character(x)) }
)
ab$as_yaml(handlers = handlers)

## ------------------------------------------------
## Method `Atomic$as_json`
## ------------------------------------------------

## Create an Atomic object.
ab <- Atomic$new(sample.int(10L), "randomValues", 10L)

## Create a simple JSON representation and print it.
cat(ab$as_json())

## Add additional headers to output.
myheaders <- list(author = "JM Potvin", date = "January 1st 2021")
cat(ab$as_json(headers = myheaders))

## Write output to a file.
ab$as_json(file = "my_atomic.json", headers = myheaders)

## Output is always encoded to UTF-8.
Encoding(ab$as_json(headers = list(utf8char = "`"))) == "UTF-8"

## You can pass additional parameters to jsonlite::toJSON().
cat(ab$as_json(headers = list(test = 1.23456789)))
cat(ab$as_json(headers = list(test = 1.23456789), digits = 8L))

## ------------------------------------------------
## Method `Atomic$set`
## ------------------------------------------------

## Update $name. You could also update $length.
b <- Atomic$new(double(10L), "wrong-name")
b$set("name", "good-name")$print()

## Trying to update $type will throw an error.
\dontrun{
b$set("type", "raw")
}
b_new <- Atomic$new(raw(10L), "good-name")
}
\seealso{
Other Blueprint classes: 
\code{\link{Blueprint}}
}
\author{
Jean-Mathieu Potvin (\href{mailto:jm@potvin.xyz}{jm@potvin.xyz})
}
\concept{Blueprint classes}
\section{Super class}{
\code{\link[blueprint:Blueprint]{blueprint::Blueprint}} -> \code{Atomic}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{name}}{A scalar character. A name for the vector.}

\item{\code{type}}{A scalar character. The class of the vector.}

\item{\code{length}}{A scalar integer. The length of the vector. If \code{NULL},
it is ignored by the class instance.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Atomic$new()}}
\item \href{#method-validate}{\code{Atomic$validate()}}
\item \href{#method-print}{\code{Atomic$print()}}
\item \href{#method-format}{\code{Atomic$format()}}
\item \href{#method-compare}{\code{Atomic$compare()}}
\item \href{#method-generate}{\code{Atomic$generate()}}
\item \href{#method-bind}{\code{Atomic$bind()}}
\item \href{#method-as_list}{\code{Atomic$as_list()}}
\item \href{#method-as_character}{\code{Atomic$as_character()}}
\item \href{#method-as_yaml}{\code{Atomic$as_yaml()}}
\item \href{#method-as_json}{\code{Atomic$as_json()}}
\item \href{#method-set}{\code{Atomic$set()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="blueprint" data-topic="Blueprint" data-id="get">}\href{../../blueprint/html/Blueprint.html#method-get}{\code{blueprint::Blueprint$get()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$new(atomic, name = character(), length = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{atomic}}{any \link[=is_strict_atomic]{strict atomic} \R vector.}

\item{\code{name}}{A scalar character. The name of the vector passed
to \code{atomic}.}

\item{\code{length}}{A scalar integer. This argument is flexible. If
\code{NULL}, \verb{$length} is ignored.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \link[R6:R6Class]{R6} object of class \link{Atomic}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{## Create a blueprint and do not enforce a length.
Atomic$new(1L, "myVectorName")

## Create a blueprint that enforces a specific length; here, 10.
Atomic$new(1L, "myVectorName", 10L)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-validate"></a>}}
\if{latex}{\out{\hypertarget{method-validate}{}}}
\subsection{Method \code{validate()}}{
Validate an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$validate()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The \link{Atomic} object invisibly if the object is valid.
Else, an error explaining what is wrong with the object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Print an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$print()}\if{html}{\out{</div>}}
}

\subsection{Details}{
The object is automatically validated before being printed.
}

\subsection{Returns}{
The \link{Atomic} object invisibly.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-format"></a>}}
\if{latex}{\out{\hypertarget{method-format}{}}}
\subsection{Method \code{format()}}{
Format an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$format(.validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? While this argument is available to the users, it should
be ignored, unless you have an alternative way to make sure your
underlying object is valid. Since it is a low-level argument, it is
not validated, so proceed with care.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A character scalar representing the formatted \link{Atomic}
object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-compare"></a>}}
\if{latex}{\out{\hypertarget{method-compare}{}}}
\subsection{Method \code{compare()}}{
Compare an object against an \link{Atomic}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$compare(object, .validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{object}}{Any \R object.}

\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? While this argument is available to the users, it should
be ignored, unless you have an alternative way to make sure your
underlying object is valid. Since it is a low-level argument, it is
not validated, so proceed with care.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A scalar logical. A \code{TRUE} means that \code{object} is in
compliance with the underlying \link{Atomic}:
\enumerate{
\item it has the same \verb{$type} and
\item if \verb{$length} is \strong{not} \code{NULL}, it has the same prescribed length.
}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{## Compare values against an Atomic blueprint that do not enforce a length.
bp_no_length <- Atomic$new("hello", "myBlueprint")

bp_no_length$compare(c("hi", "bye")) # TRUE
bp_no_length$compare("bye")          # TRUE
bp_no_length$compare(1)              # FALSE

## Compare values against an Atomic blueprint that enforces a length.
bp_length <- Atomic$new("hello", "myBlueprint", 1L)

bp_length$compare(c("hi", "bye")) # FALSE
bp_length$compare("bye")          # TRUE
bp_length$compare(1)              # FALSE
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-generate"></a>}}
\if{latex}{\out{\hypertarget{method-generate}{}}}
\subsection{Method \code{generate()}}{
Create (\emph{spawn}) a strict atomic vector from an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$generate(.validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? While this argument is available to the users, it should
be ignored, unless you have an alternative way to make sure your
underlying object is valid. Since it is a low-level argument, it is
not validated, so proceed with care.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \link[=is_strict_atomic]{strict atomic vector}. Its underlying
\code{type} and \code{length} is respectively given by fields \verb{$type} and
\verb{$length}. It is initialized with a suitable prototype derived from
argument \code{atomic} (see \code{\link[=Atomic]{new()}}) and registered internally
when the object is created.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bind"></a>}}
\if{latex}{\out{\hypertarget{method-bind}{}}}
\subsection{Method \code{bind()}}{
Create a strict atomic vector from an \link{Atomic} object
and bind it to \verb{$name} in a given environment or list-like object.

\strong{This is an experimental feature.}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$bind(where = parent.frame(), lock = FALSE, .validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{where}}{An environment or a list-like object.}

\item{\code{lock}}{A scalar logical. If \code{where} is an environment, should
the binding be locked? If so, it cannot be changed until it is
\link[base:bindenv]{unlocked}.}

\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? While this argument is available to the users, it should
be ignored, unless you have an alternative way to make sure your
underlying object is valid. Since it is a low-level argument, it is
not validated, so proceed with care.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The \link{Atomic} object invisibly if the object is valid.
Else, an error explaining what is wrong with the object.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{## Create an environment.
env <- new.env()

## Spawn a vector from a blueprint and bind the result to $name
## in env. We also lock the binding.
b <- Atomic$new(12.0, "vector", 1000L)$bind(env, TRUE)

## Trying to change value of a locked binding results in an error.
\dontrun{env$vector <- 1.0}

## You can later unlock the binding.
unlockBinding("vector", env)
env$vector <- "new value"

## Bind a prototype to $name within a list.
lst <- list(value = 1L)
b$bind(lst)
lst$vector
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-as_list"></a>}}
\if{latex}{\out{\hypertarget{method-as_list}{}}}
\subsection{Method \code{as_list()}}{
Coerce an \link{Atomic} object to a list.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$as_list(.validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? While this argument is available to the users, it should
be ignored, unless you have an alternative way to make sure your
underlying object is valid. Since it is a low-level argument, it is
not validated, so proceed with care.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A named list of four elements:
\tabular{ll}{
\code{name}      \tab A scalar character equal to \verb{$name}.\cr
\code{type}      \tab A scalar character equal to \verb{$type}.\cr
\code{length}    \tab A scalar integer equal to \verb{$length} or \code{NULL}.\cr
\code{prototype} \tab A scalar \link[=is_strict_atomic]{strict atomic value}
with a \link[base:class]{class} and a \link[base:typeof]{type} attribute
equal to \verb{$type}.
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-as_character"></a>}}
\if{latex}{\out{\hypertarget{method-as_character}{}}}
\subsection{Method \code{as_character()}}{
Coerce an \link{Atomic} object to a character.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$as_character(.validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? While this argument is available to the users, it should
be ignored, unless you have an alternative way to make sure your
underlying object is valid. Since it is a low-level argument, it is
not validated, so proceed with care.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A named character of three elements:
\tabular{ll}{
\code{name}   \tab A scalar character equal to \verb{$name}.\cr
\code{type}   \tab A scalar character equal to \verb{$type}.\cr
\code{length} \tab A scalar character equal to the coerced
value of \verb{$length} (from integer to character). If
\verb{$length} is \code{NULL}, the string \code{"NULL"} is returned.
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-as_yaml"></a>}}
\if{latex}{\out{\hypertarget{method-as_yaml}{}}}
\subsection{Method \code{as_yaml()}}{
Convert an \link{Atomic} object to a YAML text
based format.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$as_yaml(
  file = character(),
  headers = list(),
  handlers = list(),
  source_header = TRUE,
  ...,
  .validate = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{file}}{A scalar character. The name of a file to be created. If missing,
a string will be returned to the console.}

\item{\code{headers}}{A non-empty named list that holds additional key/value
pairs to include in text representations of the object (either JSON or YAML).
Ignore this argument if not needed.}

\item{\code{handlers}}{A named list of custom functions passed
to \code{\link[yaml:as.yaml]{yaml::as.yaml()}}. These handle how objects should be
converted into a YAML string. For more information, see
argument \code{handlers} of \code{\link[yaml:as.yaml]{yaml::as.yaml()}}. If missing,
a default list of handlers is used. Users can overwrite
them, but be advised that this should be reserved to
expert users.}

\item{\code{source_header}}{A scalar logical. Should a 'source' header be added?
This header gives information on how the text representation was generated.}

\item{\code{...}}{further arguments passed to \code{\link[yaml:as.yaml]{yaml::as.yaml()}}. You
cannot pass argument \code{handlers}.}

\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? While this argument is available to the users, it should
be ignored, unless you have an alternative way to make sure your
underlying object is valid. Since it is a low-level argument, it is
not validated, so proceed with care.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
YAML (\emph{YAML Ain't Markup Language}, a recursive name) is a
human-friendly data serialization standard usable in almost
any programming language. It is designed to be a strict
super-set of JSON (see \code{\link[=Atomic]{as_json()}}).
To learn more, visit \href{https://yaml.org}{yaml.org}.

Method \code{\link[=Atomic]{as_yaml()}} automatically re-encodes its
fields to UTF-8 (if applicable) before returning or writing
the YAML output. Additional headers passed to \code{headers} are
also re-encoded, if applicable.

By default, \link[base:raw]{raw} values will be encoded into
a \link[jsonlite:base64]{base64} string. This string can
be decoded again into \link[base:raw]{raw} values by using
function \code{\link[jsonlite:base64]{jsonlite::base64_dec()}}. Users can overwrite this
default behavior by passing a custom \code{raw} handler function
to argument \code{handlers}.
}

\subsection{Returns}{
If \code{file} is missing, a scalar character holding a YAML
string derived from method \code{\link[=Atomic]{as_list()}}. Else, the output
is written to \code{file} and the \link{Atomic} object is returned invisibly.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{## Create an Atomic object.
ab <- Atomic$new(sample.int(10L), "randomValues", 10L)

## Create a simple YAML representation and print it.
cat(ab$as_yaml())

## Add additional headers to output.
myheaders <- list(author = "JM Potvin", date = "January 1st 2021")
cat(ab$as_yaml(headers = myheaders))

## Write output to a file.
ab$as_yaml(file = "my_atomic.yaml", headers = myheaders)

## Output is always encoded to UTF-8.
Encoding(ab$as_yaml(headers = list(utf8char = "`"))) == "UTF-8"

## You can pass additional parameters to yaml::as.yaml().
cat(ab$as_yaml(indent = 4L))

## Use custom handlers.
## Here, we use another handler for raw values.
handlers <- list(
    raw = function(x) { return(as.character(x)) }
)
ab$as_yaml(handlers = handlers)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-as_json"></a>}}
\if{latex}{\out{\hypertarget{method-as_json}{}}}
\subsection{Method \code{as_json()}}{
Convert an \link{Atomic} object to a JSON text
based format.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$as_json(
  file = character(),
  headers = list(),
  source_header = TRUE,
  ...,
  .validate = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{file}}{A scalar character. The name of a file to be created. If missing,
a string will be returned to the console.}

\item{\code{headers}}{A non-empty named list that holds additional key/value
pairs to include in text representations of the object (either JSON or YAML).
Ignore this argument if not needed.}

\item{\code{source_header}}{A scalar logical. Should a 'source' header be added?
This header gives information on how the text representation was generated.}

\item{\code{...}}{further arguments passed to \code{\link[jsonlite:fromJSON]{jsonlite::toJSON()}}. You
cannot passe arguments \code{x} and \code{path}.}

\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? While this argument is available to the users, it should
be ignored, unless you have an alternative way to make sure your
underlying object is valid. Since it is a low-level argument, it is
not validated, so proceed with care.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
JSON (\emph{JavaScript Object Notation}) is a lightweight and
human-friendly data serialization format usable in almost
any programming language. Its design is derived from
JavaScript's objects notation. Compared to YAML, it is
slightly more verbose. To learn more, visit
\href{https://www.json.org}{www.json.org}.

Method \code{\link[=Atomic]{as_json()}} automatically re-encodes its
fields to UTF-8 (if applicable) before returning or writing
the JSON output. Additional headers passed to \code{headers} are
also re-encoded, if applicable.

By default, \link[base:raw]{raw} values will be encoded into
a \link[jsonlite:base64]{base64} string. This string can
be decoded again into \link[base:raw]{raw} values by using
function \code{\link[jsonlite:base64]{jsonlite::base64_dec()}}. Users can overwrite this
default behavior. See argument \code{raw} of \code{\link[jsonlite:fromJSON]{jsonlite::toJSON()}}.
}

\subsection{Returns}{
If \code{file} is missing, a scalar character holding a JSON
string derived from method \code{\link[=Atomic]{as_list()}}. This string is
encapsulated into an object of class \code{json}, which is internally
defined in package \pkg{jsonlite} and behaves like a normal character.
Else, the output is written to \code{file} and the \link{Atomic} object is
returned invisibly.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{## Create an Atomic object.
ab <- Atomic$new(sample.int(10L), "randomValues", 10L)

## Create a simple JSON representation and print it.
cat(ab$as_json())

## Add additional headers to output.
myheaders <- list(author = "JM Potvin", date = "January 1st 2021")
cat(ab$as_json(headers = myheaders))

## Write output to a file.
ab$as_json(file = "my_atomic.json", headers = myheaders)

## Output is always encoded to UTF-8.
Encoding(ab$as_json(headers = list(utf8char = "`"))) == "UTF-8"

## You can pass additional parameters to jsonlite::toJSON().
cat(ab$as_json(headers = list(test = 1.23456789)))
cat(ab$as_json(headers = list(test = 1.23456789), digits = 8L))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set"></a>}}
\if{latex}{\out{\hypertarget{method-set}{}}}
\subsection{Method \code{set()}}{
Update a field's value of an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$set(field = character(), value, .validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{field}}{A scalar character. The name of a field.}

\item{\code{value}}{Any \R value. The value to use when updating a field. Its
type must match the field's underlying structure.}

\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? While this argument is available to the users, it should
be ignored, unless you have an alternative way to make sure your
underlying object is valid. Since it is a low-level argument, it is
not validated, so proceed with care.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Changing the value of field \verb{$type} is forbidden, because it could
break internal prototyping mechanisms. Attempting to do so will
result in an error. If \verb{$type} must be changed, create a new \link{Atomic}
object instead.

It is worthwhile to note that \code{\link[=Atomic]{Atomic$set()}} is a safe
wrapper that calls \code{\link[=Blueprint]{Blueprint$set()}}.
}

\subsection{Returns}{
The \link{Atomic} object invisibly if the object is valid.
Else, an error explaining what is wrong with the object.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{## Update $name. You could also update $length.
b <- Atomic$new(double(10L), "wrong-name")
b$set("name", "good-name")$print()

## Trying to update $type will throw an error.
\dontrun{
b$set("type", "raw")
}
b_new <- Atomic$new(raw(10L), "good-name")
}
\if{html}{\out{</div>}}

}

}
}
