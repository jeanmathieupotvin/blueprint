% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Atomic.R
\name{Atomic}
\alias{Atomic}
\alias{is_atomic}
\alias{valid_atomic}
\title{Atomic: a class for strict atomic vectors}
\usage{
## Test if an object is an 'Atomic' object
is_atomic(x)

## Validate if an object is a proper 'Atomic' object
valid_atomic(x)
}
\arguments{
\item{x}{any \R object.}
}
\value{
\itemize{
\item External helper function \code{\link[=is_atomic]{is_atomic()}} returns a logical scalar.
}

\itemize{
\item External helper function \code{\link[=valid_atomic]{valid_atomic()}} returns a logical scalar if
the object is valid. Else, an error explaining what is wrong is returned.
}
}
\description{
\link{Atomic} is an important building block of \pkg{blueprint}: it creates
blueprints for \link[=is_strict_atomic]{strict atomic vectors} (vectors of
any \R atomic type, including \link{NULL}, that has no attribute). Instances
of the \link{Atomic} class hold useful (derived) metadata on strict vectors:
their types, names, prototypes and optionally, their lengths.
}
\section{Self-validation}{

The contents of an instance is checked when it is initialized and each time
a method is called afterward.
}

\section{Updating fields of the Atomic class}{

Users should \strong{never} manually change fields' values of an \link{Atomic} instance
manually. Instead, use \code{\link[=Atomic]{$set()}} to do it safely. Refer to the
documentation of this method (see below) for more information.
}

\examples{

## ------------------------------------------------
## Method `Atomic$new`
## ------------------------------------------------

## Create a blueprint and do not enforce a length.
Atomic$new(1L, "myVectorName")

## Create a blueprint that enforces a specific length; here, 10.
Atomic$new(1L, "myVectorName", 10L)

## ------------------------------------------------
## Method `Atomic$compare`
## ------------------------------------------------

## Compare values against an Atomic blueprint that do not enforce a length.
bp_no_length <- Atomic$new("hello", "myBlueprint")

bp_no_length$compare(c("hi", "bye")) # TRUE
bp_no_length$compare("bye")          # TRUE
bp_no_length$compare(1)              # FALSE

## Compare values against an Atomic blueprint that enforces a length.
bp_length <- Atomic$new("hello", "myBlueprint", 1L)

bp_length$compare(c("hi", "bye")) # FALSE
bp_length$compare("bye")          # TRUE
bp_length$compare(1)              # FALSE

## ------------------------------------------------
## Method `Atomic$as_yaml`
## ------------------------------------------------

## Create an Atomic object.
ab <- Atomic$new(sample.int(10L), "randomValues", 10L)

## Create a simple YAML representation and print it.
cat(ab$as_yaml())

## Add additional headers to output.
myheaders <- list(author = "JM Potvin", date = "January 1st 2021")
cat(ab$as_yaml(headers = myheaders))

## Write output to a file.
ab$as_yaml(file = "my_atomic.yaml", headers = myheaders)

## Output is always encoded to UTF-8.
Encoding(ab$as_yaml(headers = list(utf8char = "`"))) == "UTF-8"

## You can pass additional parameters to yaml::as.yaml().
cat(ab$as_yaml(indent = 4L))

## Use custom handlers.
## Here, we use another handler for raw values.
handlers <- list(
    raw = function(x) { return(as.character(x)) }
)
ab$as_yaml(handlers = handlers)

## ------------------------------------------------
## Method `Atomic$as_json`
## ------------------------------------------------

## Create an Atomic object.
ab <- Atomic$new(sample.int(10L), "randomValues", 10L)

## Create a simple JSON representation and print it.
cat(ab$as_json())

## Add additional headers to output.
myheaders <- list(author = "JM Potvin", date = "January 1st 2021")
cat(ab$as_json(headers = myheaders))

## Write output to a file.
ab$as_json(file = "my_atomic.json", headers = myheaders)

## Output is always encoded to UTF-8.
Encoding(ab$as_json(headers = list(utf8char = "`"))) == "UTF-8"

## You can pass additional parameters to jsonlite::toJSON().
cat(ab$as_json(headers = list(test = 1.23456789)))
cat(ab$as_json(headers = list(test = 1.23456789), digits = 8L))

## ------------------------------------------------
## Method `Atomic$set`
## ------------------------------------------------

## Update $name. You could also update $length.
b <- Atomic$new(double(10L), "wrong-name")
b$set("name", "good-name")$print()

## Trying to update $type will throw an error.
\dontrun{
b$set("type", "raw")
}
b_new <- Atomic$new(raw(10L), "good-name")
}
\seealso{
Other Blueprint classes: 
\code{\link{Blueprint}}
}
\author{
Jean-Mathieu Potvin (\href{mailto:jm@potvin.xyz}{jm@potvin.xyz})
}
\concept{Blueprint classes}
\section{Super class}{
\code{\link[blueprint:Blueprint]{blueprint::Blueprint}} -> \code{Atomic}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{name}}{A scalar character. A name for the vector.}

\item{\code{type}}{A scalar character. The class of the vector.}

\item{\code{length}}{A scalar integer. The length of the vector. If \code{NULL},
it is ignored by the class instance.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Atomic$new()}}
\item \href{#method-validate}{\code{Atomic$validate()}}
\item \href{#method-print}{\code{Atomic$print()}}
\item \href{#method-format}{\code{Atomic$format()}}
\item \href{#method-compare}{\code{Atomic$compare()}}
\item \href{#method-generate}{\code{Atomic$generate()}}
\item \href{#method-as_list}{\code{Atomic$as_list()}}
\item \href{#method-as_character}{\code{Atomic$as_character()}}
\item \href{#method-as_yaml}{\code{Atomic$as_yaml()}}
\item \href{#method-as_json}{\code{Atomic$as_json()}}
\item \href{#method-set}{\code{Atomic$set()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="blueprint" data-topic="Blueprint" data-id="get">}\href{../../blueprint/html/Blueprint.html#method-get}{\code{blueprint::Blueprint$get()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$new(atomic, name, length = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{atomic}}{any \link[=is_strict_atomic]{strict atomic} \R vector.}

\item{\code{name}}{A scalar character. The name of the vector passed
to \code{atomic}.}

\item{\code{length}}{A scalar integer. This argument is flexible. If
\code{NULL}, \verb{$length} is ignored.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \link[R6:R6Class]{R6} object of class \link{Atomic}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{## Create a blueprint and do not enforce a length.
Atomic$new(1L, "myVectorName")

## Create a blueprint that enforces a specific length; here, 10.
Atomic$new(1L, "myVectorName", 10L)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-validate"></a>}}
\if{latex}{\out{\hypertarget{method-validate}{}}}
\subsection{Method \code{validate()}}{
Validate an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$validate()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The \link{Atomic} object invisibly if the object is valid.
Else, an error explaining what is wrong with the object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Print an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$print()}\if{html}{\out{</div>}}
}

\subsection{Details}{
The object is automatically validated before being printed.
}

\subsection{Returns}{
The \link{Atomic} object invisibly.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-format"></a>}}
\if{latex}{\out{\hypertarget{method-format}{}}}
\subsection{Method \code{format()}}{
Format an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$format(.validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? This argument is \code{TRUE} by default. While it is available
to the users, it should be ignored, unless you have an alternative way
to make sure your underlying object is valid.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A character scalar representing the formatted \link{Atomic}
object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-compare"></a>}}
\if{latex}{\out{\hypertarget{method-compare}{}}}
\subsection{Method \code{compare()}}{
Compare an object against an \link{Atomic}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$compare(object, .validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{object}}{Any \R object.}

\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? This argument is \code{TRUE} by default. While it is available
to the users, it should be ignored, unless you have an alternative way
to make sure your underlying object is valid.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A scalar logical. A \code{TRUE} means that \code{object} is in
compliance with the underlying \link{Atomic}:
\enumerate{
\item it has the same \verb{$type} and
\item if \verb{$length} is \strong{not} \code{NULL}, it has the same prescribed length.
}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{## Compare values against an Atomic blueprint that do not enforce a length.
bp_no_length <- Atomic$new("hello", "myBlueprint")

bp_no_length$compare(c("hi", "bye")) # TRUE
bp_no_length$compare("bye")          # TRUE
bp_no_length$compare(1)              # FALSE

## Compare values against an Atomic blueprint that enforces a length.
bp_length <- Atomic$new("hello", "myBlueprint", 1L)

bp_length$compare(c("hi", "bye")) # FALSE
bp_length$compare("bye")          # TRUE
bp_length$compare(1)              # FALSE
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-generate"></a>}}
\if{latex}{\out{\hypertarget{method-generate}{}}}
\subsection{Method \code{generate()}}{
Create (\emph{spawn}) a strict atomic vector from an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$generate(.validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? This argument is \code{TRUE} by default. While it is available
to the users, it should be ignored, unless you have an alternative way
to make sure your underlying object is valid.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \link[=is_strict_atomic]{strict atomic vector}. Its underlying
\code{type} and \code{length} is respectively given by fields \verb{$type} and
\verb{$length}. It is initialized with a suitable prototype derived from
argument \code{atomic} (see \code{\link[=Atomic]{new()}}) and registered internally
when the object is created.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-as_list"></a>}}
\if{latex}{\out{\hypertarget{method-as_list}{}}}
\subsection{Method \code{as_list()}}{
Coerce an \link{Atomic} object to a list.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$as_list(.validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? This argument is \code{TRUE} by default. While it is available
to the users, it should be ignored, unless you have an alternative way
to make sure your underlying object is valid.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A named list of four elements:
\tabular{ll}{
\code{name}      \tab A scalar character equal to \verb{$name}.\cr
\code{type}      \tab A scalar character equal to \verb{$type}.\cr
\code{length}    \tab A scalar integer equal to \verb{$length} or \code{NULL}.\cr
\code{prototype} \tab A scalar \link[=is_strict_atomic]{strict atomic value}
with a \link[base:class]{class} and a \link[base:typeof]{type} attribute
equal to \verb{$type}.
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-as_character"></a>}}
\if{latex}{\out{\hypertarget{method-as_character}{}}}
\subsection{Method \code{as_character()}}{
Coerce an \link{Atomic} object to a character.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$as_character(.validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? This argument is \code{TRUE} by default. While it is available
to the users, it should be ignored, unless you have an alternative way
to make sure your underlying object is valid.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A named character of three elements:
\tabular{ll}{
\code{name}   \tab A scalar character equal to \verb{$name}.\cr
\code{type}   \tab A scalar character equal to \verb{$type}.\cr
\code{length} \tab A scalar character equal to the coerced
value of \verb{$length} (from integer to character). If
\verb{$length} is \code{NULL}, the string \code{"NULL"} is returned.
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-as_yaml"></a>}}
\if{latex}{\out{\hypertarget{method-as_yaml}{}}}
\subsection{Method \code{as_yaml()}}{
Convert an \link{Atomic} object to a YAML text
based format.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$as_yaml(file, headers, handlers, ..., .validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{file}}{A scalar character. The name of a file to be created.}

\item{\code{headers}}{A non-empty named list that holds additional key/value
pairs to include in text representations of the object (either JSON or YAML).
Ignore this argument if not needed.}

\item{\code{handlers}}{A named list of custom functions passed
to \code{\link[yaml:as.yaml]{yaml::as.yaml()}}. These handle how objects should be
converted into a YAML string. For more information, see
argument \code{handlers} of \code{\link[yaml:as.yaml]{yaml::as.yaml()}}. If missing,
a default list of handlers is used. Users can overwrite
them, but be advised that this should be reserved to
expert users.}

\item{\code{...}}{further arguments passed to \code{\link[yaml:as.yaml]{yaml::as.yaml()}}.}

\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? This argument is \code{TRUE} by default. While it is available
to the users, it should be ignored, unless you have an alternative way
to make sure your underlying object is valid.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
YAML (\emph{YAML Ain't Markup Language}, a recursive name) is a
human-friendly data serialization standard usable in almost
any programming language. It is designed to be a strict
super-set of JSON (see \code{\link[=Atomic]{as_json()}}).
To learn more, visit \href{https://yaml.org}{yaml.org}.

Method \code{\link[=Atomic]{as_yaml()}} automatically re-encodes its
fields to UTF-8 (if applicable) before returning or writing
the YAML output. Additional headers passed to \code{headers} are
also re-encoded, if applicable.

By default, \link[base:raw]{raw} values will be encoded into
a \link[jsonlite:base64]{base64} string. This string can
be decoded again into \link[base:raw]{raw} values by using
function \code{\link[jsonlite:base64]{jsonlite::base64_dec()}}. Users can overwrite this
default behavior by passing a custom \code{raw} handler function
to argument \code{handlers}.
}

\subsection{Returns}{
A scalar character holding a YAML string derived from
method \code{\link[=Atomic]{as_list()}}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{## Create an Atomic object.
ab <- Atomic$new(sample.int(10L), "randomValues", 10L)

## Create a simple YAML representation and print it.
cat(ab$as_yaml())

## Add additional headers to output.
myheaders <- list(author = "JM Potvin", date = "January 1st 2021")
cat(ab$as_yaml(headers = myheaders))

## Write output to a file.
ab$as_yaml(file = "my_atomic.yaml", headers = myheaders)

## Output is always encoded to UTF-8.
Encoding(ab$as_yaml(headers = list(utf8char = "`"))) == "UTF-8"

## You can pass additional parameters to yaml::as.yaml().
cat(ab$as_yaml(indent = 4L))

## Use custom handlers.
## Here, we use another handler for raw values.
handlers <- list(
    raw = function(x) { return(as.character(x)) }
)
ab$as_yaml(handlers = handlers)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-as_json"></a>}}
\if{latex}{\out{\hypertarget{method-as_json}{}}}
\subsection{Method \code{as_json()}}{
Convert an \link{Atomic} object to a JSON text
based format.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$as_json(file, headers, ..., .validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{file}}{A scalar character. The name of a file to be created.}

\item{\code{headers}}{A non-empty named list that holds additional key/value
pairs to include in text representations of the object (either JSON or YAML).
Ignore this argument if not needed.}

\item{\code{...}}{further arguments passed to \code{\link[jsonlite:fromJSON]{jsonlite::toJSON()}}.}

\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? This argument is \code{TRUE} by default. While it is available
to the users, it should be ignored, unless you have an alternative way
to make sure your underlying object is valid.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
JSON (\emph{JavaScript Object Notation}) is a lightweight and
human-friendly data serialization format usable in almost
any programming language. Its design is derived from
JavaScript's objects notation. Compared to YAML, it is
slightly more verbose. To learn more, visit
\href{https://www.json.org}{www.json.org}.

Method \code{\link[=Atomic]{as_json()}} automatically re-encodes its
fields to UTF-8 (if applicable) before returning or writing
the JSON output. Additional headers passed to \code{headers} are
also re-encoded, if applicable.

By default, \link[base:raw]{raw} values will be encoded into
a \link[jsonlite:base64]{base64} string. This string can
be decoded again into \link[base:raw]{raw} values by using
function \code{\link[jsonlite:base64]{jsonlite::base64_dec()}}. Users can overwrite this
default behavior. See argument \code{raw} of \code{\link[jsonlite:fromJSON]{jsonlite::toJSON()}}.
}

\subsection{Returns}{
A scalar character holding a JSON string derived from
method \code{\link[=Atomic]{as_list()}}. This string is encapsulated into
an object of class \code{json}, which is internally defined in package
\pkg{jsonlite} and behaves like a normal character.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{## Create an Atomic object.
ab <- Atomic$new(sample.int(10L), "randomValues", 10L)

## Create a simple JSON representation and print it.
cat(ab$as_json())

## Add additional headers to output.
myheaders <- list(author = "JM Potvin", date = "January 1st 2021")
cat(ab$as_json(headers = myheaders))

## Write output to a file.
ab$as_json(file = "my_atomic.json", headers = myheaders)

## Output is always encoded to UTF-8.
Encoding(ab$as_json(headers = list(utf8char = "`"))) == "UTF-8"

## You can pass additional parameters to jsonlite::toJSON().
cat(ab$as_json(headers = list(test = 1.23456789)))
cat(ab$as_json(headers = list(test = 1.23456789), digits = 8L))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set"></a>}}
\if{latex}{\out{\hypertarget{method-set}{}}}
\subsection{Method \code{set()}}{
Update a field's value of an \link{Atomic} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Atomic$set(field, value, .validate = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{field}}{A scalar character. The name of a field.}

\item{\code{value}}{Any \R value. The value to use when updating a field. Its
type must match the field's underlying structure.}

\item{\code{.validate}}{A scalar logical. Validate the object before calling
the method? This argument is \code{TRUE} by default. While it is available
to the users, it should be ignored, unless you have an alternative way
to make sure your underlying object is valid.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Changing the value of field \verb{$type} is forbidden, because it could
break internal prototyping mechanisms. Attempting to do so will
result in an error. If \verb{$type} must be changed, create a new \link{Atomic}
object instead.

It is worthwhile to note that \code{\link[=Atomic]{Atomic$set()}} is a safe
wrapper that calls \code{\link[=Blueprint]{Blueprint$set()}}.
}

\subsection{Returns}{
The \link{Atomic} object invisibly if the object is valid.
Else, an error explaining what is wrong with the object.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{## Update $name. You could also update $length.
b <- Atomic$new(double(10L), "wrong-name")
b$set("name", "good-name")$print()

## Trying to update $type will throw an error.
\dontrun{
b$set("type", "raw")
}
b_new <- Atomic$new(raw(10L), "good-name")
}
\if{html}{\out{</div>}}

}

}
}
